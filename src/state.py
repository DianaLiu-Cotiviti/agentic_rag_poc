"""
State definition for Agentic RAG system
Defines the state that flows through the LangGraph workflow
"""
from typing import TypedDict, List, Dict, Any, Optional, Literal
from pydantic import BaseModel, Field


class RetrievalResult(BaseModel):
    """Single retrieval result"""
    chunk_id: str
    score: float
    text: str
    metadata: Dict[str, Any] = Field(default_factory=dict)


class SearchGuidance(BaseModel):
    """Search guidance for retrieval optimization"""
    semantic_guidance: str = ""  # Guidance text for semantic search
    boost_terms: List[str] = Field(default_factory=list)  # Keywords to boost in hybrid search
    metadata_filters: Dict[str, Any] = Field(default_factory=dict)  # Metadata filters to apply
    target_doc_types: List[str] = Field(default_factory=list)  # Target document types
    expected_sections: List[str] = Field(default_factory=list)  # Expected document sections


class QueryCandidate(BaseModel):
    """Query candidate generated by Query Planner"""
    query: str
    query_type: Literal["original", "expanded", "synonym", "section_specific", "constraint_focused"]
    weight: float = 1.0
    guidance: Optional[SearchGuidance] = None  # Search guidance for this query


class EvidenceAssessment(BaseModel):
    """Evidence quality assessment"""
    is_sufficient: bool
    coverage_score: float  # 0-1
    specificity_score: float  # 0-1
    has_contradiction: bool
    reasoning: str
    missing_aspects: List[str] = Field(default_factory=list)


class StructuredAnswer(BaseModel):
    """Final structured answer with evidence"""
    answer: str
    rules: List[str] = Field(default_factory=list)
    allowed_modifiers: List[str] = Field(default_factory=list)
    constraints: List[str] = Field(default_factory=list)
    risks: List[str] = Field(default_factory=list)
    evidence_trace: List[Dict[str, Any]] = Field(default_factory=list)
    confidence: float = 0.0


class AgenticRAGState(TypedDict):
    """State that flows through the LangGraph workflow"""
    
    # ========== Input ==========
    question: str
    cpt_code: Optional[int]
    context: Optional[str]
    
    # ========== Orchestrator outputs (Global Strategy Decisions) ==========
    question_type: Optional[Literal["modifier", "PTP", "guideline", "definition", "comparison", "procedural", "general"]]
    question_keywords: List[str]  # Keywords extracted from query (includes CPT codes, modifiers, medical terms)
    question_complexity: Optional[Literal["simple", "medium", "complex"]]
    retrieval_strategies: List[Literal["range_routing", "bm25", "semantic", "hybrid"]]  # Ordered pipeline
    enable_retry: bool  # Whether retry is enabled
    max_retry_allowed: int  # Max retries allowed (0-3)
    require_structured_output: bool  # Whether structured extraction is needed
    orchestrator_reasoning: Optional[str]  # Orchestrator's reasoning

    
    # ========== Query Planner outputs ==========
    query_candidates: List[QueryCandidate]
    retrieval_hints: List[str]  # Strategy-level retrieval recommendations from Query Planner
    # messages: List[str]  # Log messages from agents (e.g., Query Planner metadata

    # ========== Retrieval outputs ==========
    retrieved_chunks: List[RetrievalResult]
    retrieval_metadata: Dict[str, Any]
    cpt_descriptions: Optional[Dict[str, str]]  # CPT code -> description mapping (used during retrieval)
    
    # ========== Evidence Judge outputs ==========
    evidence_assessment: Optional[EvidenceAssessment]
    retry_count: int
    
    # ========== Query Refiner outputs (for retry loop) ==========
    # refined_queries: List[str]
    
    # ========== Final outputs ==========
    # structured_answer: Optional[StructuredAnswer]
    
    # ========== Error handling ==========
    # error: Optional[str]
